--- controller.py
+++ controller.py.backup
@@ -99,28 +99,31 @@

         # --- UI and Application Setup ---
         self.setup_variables()
         self.setup_main_window()
+        self.create_widgets()
+        self.setup_bindings()
+        self.setup_gui_logging()
+
+        if KEYBOARD_LIB_AVAILABLE:
+            self.setup_global_hotkeys_enhanced()
+        else:
+            self.log_missing_keyboard_library()
+
+        # --- Staggered Startup Sequence ---
+        self.root.after(100, self.initialize_hardware_async)
+        self.root.after(200, self.load_saved_settings)
+        self.root.after(300, self.show_system_info)
+        self.root.after(600, self.apply_startup_settings_if_enabled_async)
+
+        self.logger.info(f"{APP_NAME} v{VERSION} GUI Initialized and ready.")

     def _update_brightness_text_display(self, *args):
         if hasattr(self, 'brightness_text_var') and self.brightness_text_var:
             try:
                 current_val = self.brightness_var.get()
-                if hasattr(self, 'brightness_label') and self.brightness_label.winfo_exists():
-                    self.brightness_label.config(text=f"{current_val}%")
+                [cite_start]if hasattr(self, 'brightness_label') and self.brightness_label.winfo_exists(): # [cite: 62]
+                    [cite_start]self.brightness_label.config(text=f"{current_val}%") # [cite: 62]
                 self.brightness_text_var.set(f"{current_val}%")
             except tk.TclError:
                 self.logger.debug("TclError in _update_brightness_text_display.")
@@ -133,28 +136,13 @@
         self.brightness_var = tk.IntVar(value=self.settings.get("brightness", default_settings["brightness"]))
         self.brightness_text_var = tk.StringVar(value=f"{self.brightness_var.get()}%")
         self.brightness_var.trace_add("write", self._update_brightness_text_display)
         effect_speed_setting = self.settings.get("effect_speed", default_settings["effect_speed"])
-        self.speed_var = tk.IntVar(value=effect_speed_setting * 10)
+        self.effect_speed_var = tk.IntVar(value=effect_speed_setting * 10) # Renamed from speed_var for clarity
         current_color_dict = self.settings.get("current_color", default_settings["current_color"])
         self.current_color_var = tk.StringVar(value=RGBColor.from_dict(current_color_dict).to_hex())
         self.effect_var = tk.StringVar(value=self.settings.get("effect_name", default_settings["effect_name"]))
         self.status_var = tk.StringVar(value="Initializing...")
         self.effect_color_var = tk.StringVar(value=self.settings.get("effect_color", default_settings["effect_color"]))
         self.effect_rainbow_mode_var = tk.BooleanVar(value=self.settings.get("effect_rainbow_mode", default_settings["effect_rainbow_mode"]))
         self.gradient_start_color_var = tk.StringVar(value=self.settings.get("gradient_start_color", default_settings["gradient_start_color"]))
         self.gradient_end_color_var = tk.StringVar(value=self.settings.get("gradient_end_color", default_settings["gradient_end_color"]))
         self.restore_startup_var = tk.BooleanVar(value=self.settings.get("restore_on_startup", default_settings["restore_on_startup"]))
-        self.auto_apply_var = tk.BooleanVar(value=self.settings.get("auto_apply_last_setting", default_settings["auto_apply_last_setting"]))
-        self.control_method_var = tk.StringVar(value=self.settings.get("last_control_method", default_settings["last_control_method"]))
-        self.minimize_to_tray_var = tk.BooleanVar(value=self.settings.get("minimize_to_tray", True))
-        self.setup_bindings()
-        self.setup_gui_logging()
-
-        if KEYBOARD_LIB_AVAILABLE:
-            self.setup_global_hotkeys_enhanced()
-        else:
-            self.log_missing_keyboard_library()
-
-        # --- Staggered Startup Sequence ---
-        self.root.after(100, self.initialize_hardware_async)
-        self.root.after(200, self.load_saved_settings)
-        self.root.after(300, self.show_system_info)
-        self.root.after(600, self.apply_startup_settings_if_enabled_async)
-
-        self.logger.info(f"{APP_NAME} v{VERSION} GUI Initialized and ready.")
+        [cite_start]self.auto_apply_var = tk.BooleanVar(value=self.settings.get("auto_apply_last_setting", default_settings["auto_apply_last_setting"])) # [cite: 65]
+        [cite_start]self.control_method_var = tk.StringVar(value=self.settings.get("last_control_method", default_settings["last_control_method"])) # [cite: 65]
+        [cite_start]self.minimize_to_tray_var = tk.BooleanVar(value=self.settings.get("minimize_to_tray", True)) # [cite: 65]

     def _initialize_core_components(self):
         """Initializes core non-GUI components."""
@@ -193,8 +181,8 @@
             self.effect_manager.stop_current_effect()

         self.stop_preview_animation()

-        if hasattr(self, 'hardware') and self.hardware and self.hardware.is_operational():
+        [cite_start]if hasattr(self, 'hardware') and self.hardware and self.hardware.is_operational(): # [cite: 60]
             self.hardware.clear_all_leds()

         self.zone_colors = [RGBColor(0,0,0)] * NUM_ZONES
@@ -204,7 +192,7 @@
     def setup_logging(self) -> logging.Logger:
         """Configures file-based logging with rotation."""
         logger = logging.getLogger(f"{APP_NAME}.GUI")
-        if any(isinstance(h, logging.FileHandler) for h in logger.handlers):
+        [cite_start]if any(isinstance(h, logging.FileHandler) for h in logger.handlers): # [cite: 10]
             return logger

         logger.setLevel(logging.DEBUG)
@@ -213,7 +201,7 @@
         try:
             log_dir = SETTINGS_FILE.parent / "logs"
             log_dir.mkdir(parents=True, exist_ok=True)
             log_file = log_dir / "rgb_controller_gui.log"
-            fh = logging.handlers.RotatingFileHandler(log_file, maxBytes=5*1024*1024, backupCount=3, encoding='utf-8')
+            [cite_start]fh = logging.handlers.RotatingFileHandler(log_file, maxBytes=5*1024*1024, backupCount=3, encoding='utf-8') # [cite: 11]
             fh.setLevel(logging.DEBUG)
             fh.setFormatter(formatter)
             logger.addHandler(fh)
@@ -227,10 +215,10 @@
         self.reactive_detection_methods = []

         if KEYBOARD_LIB_AVAILABLE:
-            self.reactive_detection_methods.append("keyboard_global")
-            self.logger.info("Reactive effects: Global keyboard detection available.")
+            [cite_start]self.reactive_detection_methods.append("keyboard_global") # [cite: 20]
+            [cite_start]self.logger.info("Reactive effects: Global keyboard detection available.") # [cite: 20]

         self.reactive_detection_methods.append("gui_focused")

-        if hasattr(self.hardware, 'supports_key_press_detection') and self.hardware.supports_key_press_detection():
+        [cite_start]if hasattr(self.hardware, 'supports_key_press_detection') and self.hardware.supports_key_press_detection(): # [cite: 21]
             self.reactive_detection_methods.append("hardware_ec")
             self.logger.info("Reactive effects: Hardware EC key detection available.")

@@ -242,7 +230,7 @@
         try:
             base_color_rgb = RGBColor.from_hex(self.effect_color_var.get())
         except ValueError:
-            base_color_rgb = RGBColor(255, 255, 255)
+            [cite_start]base_color_rgb = RGBColor(255, 255, 255) # [cite: 23]

         is_rainbow = self.effect_rainbow_mode_var.get()
         speed_multiplier = self.get_hardware_synchronized_speed()
@@ -262,7 +250,7 @@
         for row in self.key_grid:
             for key_info in row:
                 try:
-                    self.preview_canvas.itemconfig(key_info['element'], fill='#404040', outline='#606060', width=1)
+                    [cite_start]self.preview_canvas.itemconfig(key_info['element'], fill='#404040', outline='#606060', width=1) # [cite: 25]
                 except tk.TclError:
                     pass

@@ -345,7 +333,7 @@
         is_rainbow = self.effect_rainbow_mode_var.get()
         speed_multiplier = self.get_hardware_synchronized_speed()

-        for i in range(NUM_ZONES):
+        [cite_start]for i in range(NUM_ZONES): # [cite: 36]
             if is_rainbow:
                 hue = (i / NUM_ZONES) % 1.0
                 rgb_float = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
@@ -367,7 +355,7 @@
                 if is_rainbow:
                     hue = ((row_idx + col_idx) / 10) % 1.0
                     rgb_float = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
-                    color = RGBColor(int(rgb_float[0] * 255), int(rgb_float[1] * 255), int(rgb_float[2] * 255))
+                    [cite_start]color = RGBColor(int(rgb_float[0] * 255), int(rgb_float[1] * 255), int(rgb_float[2] * 255)) # [cite: 39]
                 try:
                     self.preview_canvas.itemconfig(key_info['element'], fill=color.to_hex(), outline='#ffffff', width=1)
                 except tk.TclError:
@@ -404,7 +392,7 @@

         for row_idx, row in enumerate(self.key_grid):
             for col_idx, key_info in enumerate(row):
-                position_factor = (15 - col_idx) / 15.0
+                [cite_start]position_factor = (15 - col_idx) / 15.0 # [cite: 49]
                 row_factor = row_idx / len(self.key_grid)

                 hue = (base_offset + position_factor + row_factor * 0.2) % 1.0
@@ -432,7 +420,7 @@

         for i in range(NUM_ZONES):
             start_idx = i * 2
-            end_idx = min(start_idx + 3, extended_zones)
+            [cite_start]end_idx = min(start_idx + 3, extended_zones) # [cite: 55]

             num_samples = end_idx - start_idx
             avg_r = sum(extended_colors[j].r for j in range(start_idx, end_idx)) // num_samples
@@ -470,7 +458,7 @@
         if self._loading_settings:
             return
         try:
-            gui_speed_value = int(float(val_str))
+            [cite_start]gui_speed_value = int(float(val_str)) # [cite: 210]
             effect_speed_internal = max(1, min(10, int(gui_speed_value / 10.0 + 0.5)))
             self.settings.set("effect_speed", effect_speed_internal)
             if self.effect_manager.is_effect_running():
@@ -491,7 +479,7 @@
         self.update_effect_controls_visibility()

         current_effect_name = self.effect_var.get()
-        is_static_effect = current_effect_name in ["Static Color", "Static Zone Colors", "Static Rainbow", "Static Gradient"]
+        [cite_start]is_static_effect = current_effect_name in ["Static Color", "Static Zone Colors", "Static Rainbow", "Static Gradient"] # [cite: 213]

         if not is_static_effect and current_effect_name != "None":
             self._update_effect_preview_only()
@@ -499,7 +487,7 @@
     def _update_effect_preview_only(self):
         """Updates only the preview canvas without applying changes to hardware."""
         current_effect_name = self.effect_var.get()
-        if current_effect_name == "None" or "Static" in current_effect_name:
+        [cite_start]if current_effect_name == "None" or "Static" in current_effect_name: # [cite: 214]
             return

         self.stop_preview_animation()
@@ -515,14 +503,14 @@
         effect_name = self.effect_var.get()
         if effect_name == "None" or "Static" in effect_name:
             return

-        if not self.effect_rainbow_mode_var.get():
+        [cite_start]if not self.effect_rainbow_mode_var.get(): # [cite: 216]
             try:
                 color = RGBColor.from_hex(self.effect_color_var.get())
                 self.zone_colors = [color] * NUM_ZONES
             except ValueError:
                 self.zone_colors = [RGBColor(0,0,0)] * NUM_ZONES
-        else:
+        [cite_start]else: # [cite: 218]
             for i in range(NUM_ZONES):
                 hue = (i / NUM_ZONES) % 1.0
                 rgb_float = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
@@ -541,7 +529,7 @@
         static_effects_map = {
             "Static Color": self.preview_static_color,
             "Static Zone Colors": lambda fc: self.preview_static_per_zone(0),
-            "Static Rainbow": lambda fc: self.preview_static_rainbow(0),
+            [cite_start]"Static Rainbow": lambda fc: self.preview_static_rainbow(0), # [cite: 221]
             "Static Gradient": lambda fc: self.preview_static_gradient(0)
         }
         if effect_name in static_effects_map:
@@ -565,7 +553,7 @@

     def preview_static_color(self, frame_count=0):
         """Previews a single static color across all zones."""
-        try:
+        [cite_start]try: # [cite: 225]
             color = RGBColor.from_hex(self.current_color_var.get())
         except ValueError:
             color = RGBColor(0,0,0)
@@ -588,14 +576,14 @@
         is_color_configurable = effect_name in color_configurable_effects

         if hasattr(self, 'effect_color_rainbow_frame') and self.effect_color_rainbow_frame.winfo_exists():
-            if is_color_configurable:
+            [cite_start]if is_color_configurable: # [cite: 228]
                 if not self.effect_color_rainbow_frame.winfo_ismapped():
                     self.effect_color_rainbow_frame.pack(fill=tk.X, pady=(0,5), anchor='w')

                 if hasattr(self, 'rainbow_mode_check') and self.rainbow_mode_check.winfo_exists():
-                    if not self.rainbow_mode_check.winfo_ismapped():
+                    [cite_start]if not self.rainbow_mode_check.winfo_ismapped(): # [cite: 229]
                         self.rainbow_mode_check.pack(side=tk.LEFT, padx=(0,10), pady=(0,5))

                 if hasattr(self, 'effect_color_frame') and self.effect_color_frame.winfo_exists():
-                    if not self.effect_rainbow_mode_var.get():
+                    [cite_start]if not self.effect_rainbow_mode_var.get(): # [cite: 229]
                         if not self.effect_color_frame.winfo_ismapped():
                             self.effect_color_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, pady=0, padx=5)
                     else:
@@ -611,12 +599,12 @@
         try:
             color = RGBColor.from_hex(hex_color_str)
             if not color.is_valid():
-                self.log_status(f"Invalid hex color: {hex_color_str}", "error")
+                [cite_start]self.log_status(f"Invalid hex color: {hex_color_str}", "error") # [cite: 232]
                 return

             if self.hardware.set_all_leds_color(color):
-                self.current_color_var.set(hex_color_str)
-                if hasattr(self, 'color_display') and self.color_display.winfo_exists():
+                [cite_start]self.current_color_var.set(hex_color_str) # [cite: 233]
+                [cite_start]if hasattr(self, 'color_display') and self.color_display.winfo_exists(): # [cite: 233]
                     self.color_display.config(bg=hex_color_str)
                 self.settings.set("current_color", color.to_dict())
                 self.settings.set("last_mode", "static")
@@ -625,7 +613,7 @@
                 self.zone_colors = [color] * NUM_ZONES
                 self.update_preview_keyboard()
             else:
-                raise HardwareError("set_all_leds_color returned false")
+                [cite_start]raise HardwareError("set_all_leds_color returned false") # [cite: 235]
         except Exception as e:
             log_error_with_context(self.logger, e, {"color": hex_color_str, "action": "apply_static_color"})
             if self.root.winfo_exists():
@@ -634,7 +622,7 @@
     def set_zone_color_interactive(self, zone_index: int):
         """Opens a color picker to set an individual zone's color."""
         if not (0 <= zone_index < NUM_ZONES and zone_index < len(self.zone_displays)):
-            self.logger.error(f"Invalid zone index {zone_index}.")
+            [cite_start]self.logger.error(f"Invalid zone index {zone_index}.") # [cite: 236]
             return

         initial_color_hex = self.zone_colors[zone_index].to_hex()
@@ -654,7 +642,7 @@
         try:
             if self.hardware.set_zone_colors(self.zone_colors):
                 self.log_status("Applied current zone colors to hardware.")
-                self.settings.set("zone_colors", [zc.to_dict() for zc in self.zone_colors])
+                [cite_start]self.settings.set("zone_colors", [zc.to_dict() for zc in self.zone_colors]) # [cite: 240]
                 self.settings.set("last_mode", "zones")
                 self.update_preview_keyboard()
             else:
@@ -670,7 +658,7 @@
         try:
             rainbow_colors = []
             for i in range(NUM_ZONES):
-                hue = i / float(NUM_ZONES) if NUM_ZONES > 0 else 0
+                [cite_start]hue = i / float(NUM_ZONES) if NUM_ZONES > 0 else 0 # [cite: 241]
                 rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
                 rainbow_colors.append(RGBColor(int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255)))

@@ -678,7 +666,7 @@
                 self.zone_colors = rainbow_colors
                 for i, color_obj in enumerate(self.zone_colors):
                     if i < len(self.zone_displays) and self.zone_displays[i].winfo_exists():
-                        self.zone_displays[i].config(bg=color_obj.to_hex())
+                        [cite_start]self.zone_displays[i].config(bg=color_obj.to_hex()) # [cite: 243]
                 self.settings.set("zone_colors", [c.to_dict() for c in self.zone_colors])
                 self.settings.set("last_mode", "rainbow_zones")
                 self.log_status("Applied rainbow pattern to zones.")
@@ -695,7 +683,7 @@
             start_color = RGBColor.from_hex(self.gradient_start_color_var.get())
             end_color = RGBColor.from_hex(self.gradient_end_color_var.get())
             gradient_colors = []
-            for i in range(NUM_ZONES):
+            [cite_start]for i in range(NUM_ZONES): # [cite: 246]
                 ratio = i / float(NUM_ZONES - 1) if NUM_ZONES > 1 else 0.0
                 r = int(start_color.r*(1-ratio)+end_color.r*ratio)
                 g = int(start_color.g*(1-ratio)+end_color.g*ratio)
@@ -705,7 +693,7 @@
             if self.hardware.set_zone_colors(gradient_colors):
                 self.zone_colors = gradient_colors
                 for i, color_obj in enumerate(self.zone_colors):
-                    if i < len(self.zone_displays) and self.zone_displays[i].winfo_exists():
+                    [cite_start]if i < len(self.zone_displays) and self.zone_displays[i].winfo_exists(): # [cite: 248]
                         self.zone_displays[i].config(bg=color_obj.to_hex())
                 self.settings.set("zone_colors", [c.to_dict() for c in self.zone_colors])
                 self.settings.set("last_mode", "gradient_zones")
@@ -724,7 +712,7 @@
         black = RGBColor(0,0,0)
         self.zone_colors = [black] * NUM_ZONES
         for zd in self.zone_displays:
-            if hasattr(zd, 'winfo_exists') and zd.winfo_exists():
+            [cite_start]if hasattr(zd, 'winfo_exists') and zd.winfo_exists(): # [cite: 251]
                 zd.config(bg=black.to_hex())

         self.current_color_var.set(black.to_hex())
@@ -743,7 +731,7 @@

         result = colorchooser.askcolor(initialcolor=self.current_color_var.get(), title="Choose Static Color", parent=self.root)
         if result and result[1]:
-            self.current_color_var.set(result[1])
+            [cite_start]self.current_color_var.set(result[1]) # [cite: 253]
             if hasattr(self, 'color_display') and self.color_display.winfo_exists():
                 self.color_display.config(bg=result[1])

@@ -754,7 +742,7 @@
     def choose_effect_color(self):
         """Opens the color picker for the current effect's base color."""
         result = colorchooser.askcolor(initialcolor=self.effect_color_var.get(), title="Choose Effect Base Color", parent=self.root)
-        if result and result[1]:
+        [cite_start]if result and result[1]: # [cite: 255]
             self.effect_color_var.set(result[1])
             if hasattr(self,'effect_color_display') and self.effect_color_display.winfo_exists():
                 self.effect_color_display.config(bg=result[1])
@@ -765,7 +753,7 @@
     def choose_gradient_start(self):
         """Opens the color picker for the gradient start color."""
         result = colorchooser.askcolor(initialcolor=self.gradient_start_color_var.get(), title="Choose Gradient Start Color", parent=self.root)
-        if result and result[1]:
+        [cite_start]if result and result[1]: # [cite: 256]
             self.gradient_start_color_var.set(result[1])
             if hasattr(self,'gradient_start_display') and self.gradient_start_display.winfo_exists():
                 self.gradient_start_display.config(bg=result[1])
@@ -777,7 +765,7 @@
     def choose_gradient_end(self):
         """Opens the color picker for the gradient end color."""
         result = colorchooser.askcolor(initialcolor=self.gradient_end_color_var.get(), title="Choose Gradient End Color", parent=self.root)
-        if result and result[1]:
+        [cite_start]if result and result[1]: # [cite: 258]
             self.gradient_end_color_var.set(result[1])
             if hasattr(self,'gradient_end_display') and self.gradient_end_display.winfo_exists():
                 self.gradient_end_display.config(bg=result[1])
@@ -794,7 +782,7 @@
             "Static Color": lambda: self.apply_static_color(self.current_color_var.get()),
             "Static Zone Colors": self.apply_current_zone_colors_to_hardware,
             "Static Rainbow": self.apply_rainbow_zones,
-            "Static Gradient": self.apply_gradient_zones
+            [cite_start]"Static Gradient": self.apply_gradient_zones # [cite: 260]
         }
         if effect_name in static_effects_map:
             static_effects_map[effect_name]()
@@ -802,9 +790,9 @@
             return

         if effect_name in ["Reactive", "Anti-Reactive"]:
-            self.setup_reactive_effects_system()
+            [cite_start]self.setup_reactive_effects_system() # [cite: 261]
             params = {
-                "speed": self.effect_speed_var.get(),
+                [cite_start]"speed": self.effect_speed_var.get(), # [cite: 262]
                 "rainbow_mode": self.effect_rainbow_mode_var.get()
             }
             try:
@@ -831,7 +819,7 @@
             return

         params = {
-            "speed": self.effect_speed_var.get(),
+            [cite_start]"speed": self.effect_speed_var.get(), # [cite: 266]
             "rainbow_mode": self.effect_rainbow_mode_var.get()
         }
         try:
@@ -839,7 +827,7 @@
         except ValueError:
             params["color"] = RGBColor(0,0,0)

-        if self.effect_manager.start_effect(effect_name, **params):
+        [cite_start]if self.effect_manager.start_effect(effect_name, **params): # [cite: 268]
             self.log_status(f"Started effect: {effect_name}")
             self.settings.set("effect_name", effect_name)
             self.settings.set("last_mode", "effect")
@@ -865,7 +853,7 @@
     def restart_current_effect(self):
         """Restarts the current effect, applying any changed parameters."""
         effect_name = self.effect_var.get()
-        if effect_name != "None" and "Static" not in effect_name:
+        [cite_start]if effect_name != "None" and "Static" not in effect_name: # [cite: 276]
             self.log_status(f"Restarting effect: {effect_name}")
             self.root.after(50, self.start_current_effect)
         elif self.preview_animation_active:
@@ -890,7 +878,7 @@

         if hasattr(self.hardware, 'set_control_method_preference'):
             try:
-                self.hardware.set_control_method_preference(method)
+                [cite_start]self.hardware.set_control_method_preference(method) # [cite: 279]
                 self.logger.info(f"Notified HardwareController of preference: {method}")
             except Exception as e:
                 self.logger.error(f"Error notifying HardwareController of preference change: {e}")
@@ -904,7 +892,7 @@
 ====================
 1. Research your device's specific Embedded Controller (EC) commands.
 2. Modify `gui/hardware/controller.py` to implement EC direct methods.
-3. Use caution: Incorrect EC commands can cause system instability or damage.
+3. Use caution: Incorrect EC commands can cause system instability or damage. [cite_start]# [cite: 285]

 A full guide has been written to the Application Log in the Diagnostics tab."""
         self.logger.warning(f"{msg_title}: EC Direct selected but requires implementation")
@@ -916,7 +904,7 @@
         if self.root.winfo_exists() and messagebox.askyesno("Confirm Reset", "Reset all settings to defaults? This cannot be undone.", parent=self.root):
             self._stop_all_visuals_and_clear_hardware()
             self.settings.reset_to_defaults()
-            self.load_saved_settings()
+            [cite_start]self.load_saved_settings() # [cite: 292]
             default_color = RGBColor.from_dict(default_settings["current_color"])
             self.apply_static_color(default_color.to_hex())
             self.log_status("All settings reset to defaults.")
@@ -930,7 +918,7 @@
         if fpath:
             try:
                 with open(fpath, 'w', encoding='utf-8') as f:
-                    json.dump(self.settings._settings, f, indent=2)
+                    [cite_start]json.dump(self.settings._settings, f, indent=2) # [cite: 294]
                 self.log_status(f"Settings exported to {fpath}")
                 if self.root.winfo_exists():
                     messagebox.showinfo("Export Successful", f"Settings exported to:\n{fpath}", parent=self.root)
@@ -951,7 +939,7 @@

         try:
             fpath = Path(fpath_str).resolve()
-            if not str(fpath).startswith(str(Path.home())):
+            [cite_start]if not str(fpath).startswith(str(Path.home())): # [cite: 297]
                 messagebox.showerror("Security Error", "Cannot import files from outside your home directory.", parent=self.root)
                 self.log_status("Import blocked: attempt to read from a sensitive location.", "error")
                 return
@@ -961,12 +949,12 @@

         try:
             with open(fpath, 'r', encoding='utf-8') as f:
-                imported_data = json.load(f)
+                [cite_start]imported_data = json.load(f) # [cite: 299]

             is_valid, error_msg = self._validate_settings_data(imported_data)
             if not is_valid:
                 raise ConfigurationError(f"Invalid settings file: {error_msg}")

             self._stop_all_visuals_and_clear_hardware()
-            self.settings.update(imported_data)
+            [cite_start]self.settings.update(imported_data) # [cite: 299]
             self.settings.save_settings()
             self.load_saved_settings()

@@ -985,7 +973,7 @@
     def _validate_settings_data(self, data: dict) -> Tuple[bool, str]:
         """Validates the structure, types, and value ranges of imported settings data."""
         if not isinstance(data, dict):
-            return False, "Settings file must contain a JSON object."
+            return False, "Settings file must contain a JSON object." [cite_start]# [cite: 302]

         expected_types = {
             "brightness": int, "effect_speed": int, "effect_name": str,
@@ -995,7 +983,7 @@
         for key, expected_type in expected_types.items():
             if key not in data:
                 return False, f"Required setting '{key}' is missing."
-            if not isinstance(data[key], expected_type):
+            [cite_start]if not isinstance(data[key], expected_type): # [cite: 304]
                 return False, f"Setting '{key}' has incorrect type. Expected {expected_type.__name__}."

         if not 0 <= data["brightness"] <= 100:
@@ -1010,7 +998,7 @@
         if len(data["zone_colors"]) != NUM_ZONES:
              return False, f"Expected {NUM_ZONES} zone colors, but found {len(data['zone_colors'])}."
         for i, zc in enumerate(data["zone_colors"]):
-            if not isinstance(zc, dict) or not all(k in zc for k in ['r', 'g', 'b']):
+            [cite_start]if not isinstance(zc, dict) or not all(k in zc for k in ['r', 'g', 'b']): # [cite: 306]
                 return False, f"Zone color at index {i} is malformed."

         return True, "Validation successful."
@@ -1025,7 +1013,7 @@
             python_exe = sys.executable
             # This assumes the script is run as a module from the project root
             project_root_dir = Path.cwd()
-            module_to_run = "gui.controller" # Adjust if your main entry point is different
+            [cite_start]module_to_run = "gui.controller" # Adjust if your main entry point is different # [cite: 307]

             exec_cmd = f'{shlex.quote(str(python_exe))} -m {module_to_run}'

@@ -1045,7 +1033,7 @@
                     loc.mkdir(parents=True, exist_ok=True)
                     file_path = loc / f"{APP_NAME.lower().replace(' ','-')}.desktop"
                     file_path.write_text(content, encoding='utf-8')
-                    file_path.chmod(0o755)
+                    [cite_start]file_path.chmod(0o755) # [cite: 16]
                     success_paths.append(f"âœ“ {loc.name}: {file_path}")
                 except (IOError, PermissionError) as e:
                     self.logger.error(f"Failed to create launcher at {loc}: {e}")
@@ -1067,7 +1055,7 @@
     def handle_exception_standalone(exc_type, exc_value, exc_traceback):
         app_instance = app_instance_ref[0]
         if issubclass(exc_type, KeyboardInterrupt):
-            module_logger.info("KeyboardInterrupt received. Shutting down.")
+            [cite_start]module_logger.info("KeyboardInterrupt received. Shutting down.") # [cite: 545]
             if app_instance:
                 app_instance.perform_final_shutdown(clean_shutdown=False)
             sys.exit(1)
@@ -1093,7 +1081,7 @@
     try:
         root = tk.Tk()
         app_instance_ref[0] = RGBControllerGUI(root)
-        root.mainloop()
+        [cite_start]root.mainloop() # [cite: 560]
     except SystemExit:
         module_logger.info("SystemExit caught in main, application exiting.")
     except Exception:
@@ -1106,7 +1094,7 @@

 if __name__ == "__main__":
     if not __package__:
-        script_dir = Path(__file__).resolve().parent
+        [cite_start]script_dir = Path(__file__).resolve().parent # [cite: 563]
         project_root = script_dir.parent
         if str(project_root) not in sys.path:
             sys.path.insert(0, str(project_root))
