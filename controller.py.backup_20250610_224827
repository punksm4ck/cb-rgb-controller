#!/usr/bin/env python3
"""Hardware control implementation with full 4-zone RGB support - Enhanced Version"""

import os
import time
import threading
import subprocess
import logging
import re
from typing import List, Tuple, Optional, Dict, Any
from pathlib import Path

from ..core.rgb_color import RGBColor
from ..core.exceptions import HardwareError, ConfigurationError
from ..core.constants import NUM_ZONES, LEDS_PER_ZONE, TOTAL_LEDS, APP_NAME

# Use the system ectool
ECTOOL_EXECUTABLE = "/usr/local/bin/ectool"

class HardwareController:
    def __init__(self):
        self.logger = logging.getLogger(f"{APP_NAME}.HardwareController")
        self.detection_complete = threading.Event()
        self.ectool_available = False
        self.ec_direct_available = False
        self.hardware_ready = False

        self.preferred_control_method: Optional[str] = "ectool"
        self.active_control_method: str = "none"

        self.capabilities: Dict[str, bool] = {
            "ectool_present": False,
            "ectool_version_ok": False,
            "ectool_rgbkbd_functional": False,
            "ectool_rgbkbd_clear_functional": False,
            "ectool_rgbkbd_demo_off_functional": False,
            "ectool_pwmsetkblight_ok": False,
            "ectool_pwmgetkblight_ok": False,
            "ec_direct_access_ok": False,
        }

        self.current_brightness = 100
        self._lock = threading.RLock()
        self._zone_colors_cache: List[RGBColor] = [RGBColor(0,0,0) for _ in range(NUM_ZONES)]
        self._is_effect_running = False
        self._app_exiting_cleanly = False
        
        # Reactive effects state
        self._reactive_mode_enabled = False
        self._reactive_color = RGBColor(255, 255, 255)
        self._anti_reactive_mode = False

        self._detection_thread = threading.Thread(target=self._perform_hardware_detection, daemon=True, name="HardwareDetectionThread")
        self._detection_thread.start()

    def set_control_method_preference(self, method: str):
        self.logger.info(f"Control method preference received: {method}")
        if method in ["ectool", "ec_direct"]:
            with self._lock:
                self.preferred_control_method = method
                if self.detection_complete.is_set():
                    self._update_active_method_based_on_preference()

    def _update_active_method_based_on_preference(self):
        new_active_method = "none"
        preferred = self.preferred_control_method

        if preferred == "ectool" and self.ectool_available:
            new_active_method = "ectool"
        elif preferred == "ec_direct" and self.ec_direct_available:
            new_active_method = "ec_direct"
        elif self.ectool_available:
            new_active_method = "ectool"

        self.active_control_method = new_active_method
        self.hardware_ready = new_active_method != "none"

    def _perform_hardware_detection(self) -> None:
        self.logger.info("Starting hardware detection process")
        try:
            self._detect_ectool()
            self._detect_ec_direct()
            self._update_active_method_based_on_preference()
            
            if not self.hardware_ready:
                self.logger.warning("No RGB control methods detected")
            else:
                self.logger.info(f"Hardware detection completed. Active method: '{self.active_control_method}'")
        except Exception as e:
            self.logger.error(f"Error during hardware detection: {e}", exc_info=True)
            self.hardware_ready = False
            self.active_control_method = "none"
        finally:
            self.detection_complete.set()

    def _detect_ectool(self) -> None:
        self.logger.debug(f"Detecting ectool at: {ECTOOL_EXECUTABLE}")
        self.ectool_available = False
        
        if not Path(ECTOOL_EXECUTABLE).is_file():
            self.logger.warning(f"ectool not found at: {ECTOOL_EXECUTABLE}")
            return
        
        self.capabilities["ectool_present"] = True
        
        try:
            # Test basic functionality
            success, _, _ = self._run_ectool_cmd(['version'], timeout=3.0)
            self.capabilities["ectool_version_ok"] = success
            
            if success:
                self.ectool_available = True
                self.logger.info("ectool detected and functional")
        except Exception as e:
            self.logger.error(f"Error testing ectool: {e}")

    def _detect_ec_direct(self) -> None:
        self.logger.info("EC Direct mode not fully implemented")
        self.capabilities["ec_direct_access_ok"] = False
        self.ec_direct_available = False

    def _run_ectool_cmd(self, args: List[str], timeout: float = 2.0) -> Tuple[bool, str, str]:
        cmd = [ECTOOL_EXECUTABLE] + args
        try:
            result = subprocess.run(cmd, capture_output=True, timeout=timeout, text=True)
            success = result.returncode == 0
            stdout = result.stdout.strip() if result.stdout else ""
            stderr = result.stderr.strip() if result.stderr else ""
            return success, stdout, stderr
        except subprocess.TimeoutExpired:
            return False, "", "Command timeout"
        except Exception as e:
            return False, "", str(e)

    def set_brightness(self, brightness_percent: int) -> bool:
        brightness_percent = max(0, min(100, brightness_percent))
        self.logger.debug(f"Setting brightness to {brightness_percent}%")
        
        with self._lock:
            if self.active_control_method == "ectool":
                success, _, stderr = self._run_ectool_cmd(['pwmsetkblight', str(brightness_percent)])
                if success:
                    self.current_brightness = brightness_percent
                    self.logger.info(f"Brightness set to {brightness_percent}%")
                else:
                    self.logger.warning(f"Failed to set brightness: {stderr}")
                return success
            else:
                self.logger.warning("No active control method for brightness")
                return False

    def get_brightness(self) -> int:
        with self._lock:
            if self.active_control_method == "ectool":
                success, stdout, _ = self._run_ectool_cmd(['pwmgetkblight'])
                if success and stdout:
                    match = re.search(r'(\d+)', stdout)
                    if match:
                        brightness = int(match.group(1))
                        self.current_brightness = max(0, min(100, brightness))
                        return self.current_brightness
            return self.current_brightness

    def set_zone_color(self, zone_index_1_based: int, color: RGBColor) -> bool:
        if not (1 <= zone_index_1_based <= NUM_ZONES):
            self.logger.error(f"Invalid zone index: {zone_index_1_based}")
            return False
        
        zone_0_based = zone_index_1_based - 1
        self.logger.debug(f"Setting zone {zone_index_1_based} to {color.to_hex()}")
        
        with self._lock:
            if self.active_control_method == "ectool":
                packed_color = (color.r << 16) | (color.g << 8) | color.b
                start_led = zone_0_based * LEDS_PER_ZONE
                
                # Set all LEDs in the zone to the same color
                args = ['rgbkbd', str(start_led), str(packed_color)]
                for _ in range(LEDS_PER_ZONE - 1):
                    args.append(str(packed_color))
                
                success, _, stderr = self._run_ectool_cmd(args)
                if success:
                    self._zone_colors_cache[zone_0_based] = color
                    self.logger.debug(f"Zone {zone_index_1_based} set successfully")
                else:
                    self.logger.warning(f"Failed to set zone {zone_index_1_based}: {stderr}")
                return success
            else:
                self.logger.warning("No active control method for zone color")
                return False

    def set_zone_colors(self, zone_colors: List[RGBColor]) -> bool:
        if len(zone_colors) != NUM_ZONES:
            self.logger.error(f"Expected {NUM_ZONES} colors, got {len(zone_colors)}")
            return False
        
        all_success = True
        with self._lock:
            for i, color in enumerate(zone_colors):
                if not self.set_zone_color(i + 1, color):
                    all_success = False
                time.sleep(0.01)  # Small delay between commands
        return all_success

    def set_all_leds_color(self, color: RGBColor) -> bool:
        self.logger.debug(f"Setting all LEDs to {color.to_hex()}")
        
        with self._lock:
            if self.active_control_method == "ectool":
                packed_color = (color.r << 16) | (color.g << 8) | color.b
                success, _, stderr = self._run_ectool_cmd(['rgbkbd', 'clear', str(packed_color)])
                
                if success:
                    self.logger.info(f"All LEDs set to {color.to_hex()}")
                    self._zone_colors_cache = [color] * NUM_ZONES
                    return True
                else:
                    self.logger.warning(f"Failed to set all LEDs: {stderr}")
                    # Fallback to per-zone setting
                    return self.set_zone_colors([color] * NUM_ZONES)
            else:
                self.logger.warning("No active control method for all LEDs")
                return False

    def clear_all_leds(self) -> bool:
        self.logger.info("Clearing all LEDs")
        return self.set_all_leds_color(RGBColor(0, 0, 0))

    def attempt_stop_hardware_effects(self) -> bool:
        self.logger.info("Attempting to stop hardware effects")
        with self._lock:
            if self.active_control_method == "ectool":
                success, _, _ = self._run_ectool_cmd(['rgbkbd', 'demo', '0'])
                if success:
                    return self.clear_all_leds()
                else:
                    return self.clear_all_leds()
            return False

    def get_zone_color(self, zone_index_1_based: int) -> Optional[RGBColor]:
        if not (1 <= zone_index_1_based <= NUM_ZONES):
            return None
        with self._lock:
            return self._zone_colors_cache[zone_index_1_based - 1]

    def get_all_zone_colors(self) -> List[RGBColor]:
        with self._lock:
            return self._zone_colors_cache[:]

    def get_hardware_info(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "ectool_available": self.ectool_available,
                "ec_direct_available": self.ec_direct_available,
                "hardware_ready": self.is_operational(),
                "active_control_method": self.active_control_method,
                "capabilities": self.capabilities.copy(),
                "current_brightness": self.current_brightness,
                "num_zones": NUM_ZONES,
                "total_leds": TOTAL_LEDS,
            }

    def get_active_method_display(self) -> str:
        if not self.detection_complete.is_set():
            return "Detecting..."
        if self.active_control_method == "ectool":
            return "ectool"
        elif self.active_control_method == "ec_direct":
            return "EC Direct"
        return "None"

    def wait_for_detection(self, timeout: float = 10.0) -> bool:
        return self.detection_complete.wait(timeout)

    def is_operational(self) -> bool:
        return self.hardware_ready and self.detection_complete.is_set()

    def is_effect_running(self) -> bool:
        return self._is_effect_running

    def set_effect_running_status(self, status: bool):
        self._is_effect_running = status

    def set_app_exiting_cleanly(self, status: bool):
        self._app_exiting_cleanly = status

    def stop_current_effect(self):
        self.set_effect_running_status(False)
        self.attempt_stop_hardware_effects()

    def set_reactive_mode(self, enabled: bool, color: RGBColor, anti_mode: bool = False) -> bool:
        """Enable/disable reactive mode with specified color"""
        self.logger.info(f"Setting reactive mode: enabled={enabled}, anti_mode={anti_mode}, color={color.to_hex()}")
        
        with self._lock:
            if enabled:
                self._reactive_mode_enabled = True
                self._reactive_color = color
                self._anti_reactive_mode = anti_mode
                
                # Initialize keyboard state
                if anti_mode:
                    # Anti-reactive: start with all keys on
                    return self.set_all_leds_color(color)
                else:
                    # Reactive: start with all keys off
                    return self.clear_all_leds()
            else:
                self._reactive_mode_enabled = False
                return self.clear_all_leds()

    def handle_key_press(self, key_position: int, pressed: bool) -> bool:
        """Handle individual key press for reactive effects"""
        if not getattr(self, '_reactive_mode_enabled', False):
            return True  # Not in reactive mode
        
        try:
            # Convert key position to zone (simplified mapping)
            zone_index = min(key_position // (TOTAL_LEDS // NUM_ZONES), NUM_ZONES - 1)
            
            if getattr(self, '_anti_reactive_mode', False):
                # Anti-reactive: turn off when pressed
                target_color = RGBColor(0, 0, 0) if pressed else getattr(self, '_reactive_color', RGBColor(255, 255, 255))
            else:
                # Reactive: turn on when pressed
                target_color = getattr(self, '_reactive_color', RGBColor(255, 255, 255)) if pressed else RGBColor(0, 0, 0)
            
            return self.set_zone_color(zone_index + 1, target_color)
        
        except Exception as e:
            self.logger.error(f"Error handling key press {key_position}: {e}")
            return False

    def simulate_key_press_pattern(self, pattern_name: str = "typing") -> bool:
        """Simulate key press patterns for testing reactive effects"""
        if not getattr(self, '_reactive_mode_enabled', False):
            return False
        
        try:
            if pattern_name == "typing":
                # Simulate typing pattern across zones
                for zone in range(NUM_ZONES):
                    if getattr(self, '_anti_reactive_mode', False):
                        # Anti-reactive: briefly turn off each zone
                        self.set_zone_color(zone + 1, RGBColor(0, 0, 0))
                        time.sleep(0.1)
                        self.set_zone_color(zone + 1, getattr(self, '_reactive_color', RGBColor(255, 255, 255)))
                    else:
                        # Reactive: briefly turn on each zone
                        self.set_zone_color(zone + 1, getattr(self, '_reactive_color', RGBColor(255, 255, 255)))
                        time.sleep(0.1)
                        self.set_zone_color(zone + 1, RGBColor(0, 0, 0))
                return True
            
            return False
        
        except Exception as e:
            self.logger.error(f"Error simulating key press pattern: {e}")
            return False

    def __del__(self):
        if not self._app_exiting_cleanly:
            try:
                if self.active_control_method == "ectool" and self.ectool_available:
                    self.clear_all_leds()
            except:
                pass
