#!/usr/bin/env python3
"""RGB lighting effects implementation with comprehensive error handling"""

import time
import math
import colorsys
import random
import threading
import logging
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass, field

from ..core.rgb_color import RGBColor
from ..core.constants import NUM_ZONES, LEDS_PER_ZONE, MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1, TOTAL_LEDS, REACTIVE_DELAY
from ..hardware.controller import HardwareController 
from ..utils.decorators import safe_execute 

@dataclass
class EffectState:
    """Maintains state for effects that need persistence between frames."""
    hue_offset: float = 0.0
    wave_position: float = 0.0 
    direction: int = 1
    position: int = 0 
    frame_count: int = 0
    raindrops: List[Dict[str, Any]] = field(default_factory=list)
    ripple_sources: List[Dict[str, Any]] = field(default_factory=list) 


class EffectLibrary:
    logger = logging.getLogger('EffectLibrary')

    @staticmethod
    @safe_execute()
    def static_color(hardware: HardwareController, color: RGBColor, **kwargs):
        EffectLibrary.logger.info(f"Applying static color: {color.to_hex()}")
        if not hardware.set_all_leds_color(color):
            EffectLibrary.logger.warning("Static color: Hardware command failed")

    @staticmethod
    @safe_execute()
    def static_zone_colors(hardware: HardwareController, zone_colors: List[RGBColor], **kwargs):
        if not isinstance(zone_colors, list) or len(zone_colors) != NUM_ZONES:
            EffectLibrary.logger.error(f"Static zone colors: Expected list of {NUM_ZONES} RGBColor objects, got {type(zone_colors)} len {len(zone_colors) if isinstance(zone_colors,list) else 'N/A'}")
            return
        EffectLibrary.logger.info(f"Applying static zone colors: {[zc.to_hex() for zc in zone_colors]}")
        if not hardware.set_zone_colors(zone_colors):
            EffectLibrary.logger.warning("Static zone colors: Hardware command failed")

    @staticmethod
    @safe_execute()
    def static_rainbow(hardware: HardwareController, **kwargs) -> None:
        EffectLibrary.logger.info("Applying static rainbow effect.")
        zone_colors_list: List[RGBColor] = []
        for zone_idx in range(NUM_ZONES):
            hue = zone_idx / float(NUM_ZONES) if NUM_ZONES > 0 else 0
            r_float, g_float, b_float = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
            zone_colors_list.append(RGBColor(int(r_float * 255), int(g_float * 255), int(b_float * 255)))
        if not hardware.set_zone_colors(zone_colors_list):
            EffectLibrary.logger.warning("Static rainbow: Hardware command failed")

    @staticmethod
    @safe_execute()
    def static_gradient(hardware: HardwareController, start_color: RGBColor, end_color: RGBColor, **kwargs) -> None:
        EffectLibrary.logger.info(f"Applying static gradient: from {start_color.to_hex()} to {end_color.to_hex()}")
        zone_colors_list: List[RGBColor] = []
        for zone_idx in range(NUM_ZONES):
            ratio = zone_idx / float(NUM_ZONES - 1) if NUM_ZONES > 1 else 0.0
            interpolated_color = start_color.interpolate(end_color, ratio)
            zone_colors_list.append(interpolated_color)
        if not hardware.set_zone_colors(zone_colors_list):
            EffectLibrary.logger.warning("Static gradient: Hardware command failed")

    @staticmethod
    @safe_execute()
    def breathing(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting breathing effect: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / speed) 
        error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                base_color_to_use = color
                if rainbow_mode: state.hue_offset = (state.hue_offset + 0.002 * speed) % 1.0; base_color_to_use = RGBColor.from_hsv(state.hue_offset, 1.0, 1.0)
                brightness_sine = (math.sin(state.frame_count * 0.05 * speed * 0.2) + 1) / 2.0; min_breath_brightness = 0.1
                current_brightness_factor = min_breath_brightness + (1.0 - min_breath_brightness) * brightness_sine
                dimmed_color = base_color_to_use.with_brightness(current_brightness_factor)
                if not hardware.set_all_leds_color(dimmed_color):
                    EffectLibrary.logger.warning("Breathing: set_all_leds_color failed."); error_count += 1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break 
                else: error_count = 0
                if stop_event.wait(delay_factor * 0.5): break
                state.frame_count += 1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in breathing: {e}", exc_info=True); error_count+=1
                time.sleep(0.2) 
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in breathing effect. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info(f"Breathing effect ({'rainbow' if rainbow_mode else color.to_hex()}) stopped.")

    @staticmethod
    @safe_execute()
    def color_cycle(stop_event: threading.Event, hardware: HardwareController, speed: int, **kwargs):
        EffectLibrary.logger.info(f"Starting color cycle (rainbow) effect: speed={speed}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / (speed * 2))
        error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                current_color = RGBColor.from_hsv(state.hue_offset, 1.0, 1.0)
                if not hardware.set_all_leds_color(current_color):
                    EffectLibrary.logger.warning("Color Cycle: set_all_leds_color failed."); error_count += 1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                state.hue_offset = (state.hue_offset + 0.001 * speed) % 1.0
                if stop_event.wait(delay_factor): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in color_cycle: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in color_cycle effect. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Color cycle effect stopped.")

    @staticmethod
    @safe_execute()
    def wave(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting wave effect: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / speed)
        wave_width_zones = 1.5; error_count = 0; max_local_errors = 5; state.wave_position = -wave_width_zones 
        while not stop_event.is_set():
            try:
                zone_colors = [RGBColor(0,0,0)] * NUM_ZONES
                base_color_to_use = color
                if rainbow_mode: state.hue_offset = (state.hue_offset + 0.0005 * speed) % 1.0
                for zone_idx in range(NUM_ZONES):
                    zone_center_norm = (zone_idx + 0.5) / float(NUM_ZONES) if NUM_ZONES > 0 else 0.0
                    wave_peak_norm = state.wave_position / float(NUM_ZONES) if NUM_ZONES > 0 else 0.0
                    distance = abs(zone_center_norm - wave_peak_norm)
                    intensity = 0.0; normalized_wave_width = wave_width_zones / float(NUM_ZONES) if NUM_ZONES > 0 else 0.1
                    if distance < normalized_wave_width: intensity = (math.cos((distance / normalized_wave_width) * (math.pi / 2)))**2
                    current_zone_color = base_color_to_use
                    if rainbow_mode: segment_hue = (state.hue_offset + (zone_idx / float(NUM_ZONES)) * 0.2) % 1.0; current_zone_color = RGBColor.from_hsv(segment_hue, 1.0, 1.0)
                    zone_colors[zone_idx] = current_zone_color.with_brightness(intensity)
                if not hardware.set_zone_colors(zone_colors): 
                    EffectLibrary.logger.warning("Wave: set_zone_colors failed."); error_count += 1; 
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                state.wave_position += 0.05 * speed 
                if state.wave_position > NUM_ZONES + wave_width_zones: state.wave_position = -wave_width_zones 
                if stop_event.wait(delay_factor * 0.5): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in wave: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in wave effect. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Wave effect stopped.")

    @staticmethod
    @safe_execute()
    def pulse(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting pulse: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = BASE_ANIMATION_DELAY_SPEED_1 / speed; error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                base_color = color
                if rainbow_mode: state.hue_offset = (state.hue_offset + 0.005 * speed) % 1.0; base_color = RGBColor.from_hsv(state.hue_offset, 1.0, 1.0)
                frames_per_state = max(2, int(10 / speed))
                is_on_state = (state.frame_count // frames_per_state) % 2 == 0
                color_to_set = base_color if is_on_state else RGBColor(0,0,0)
                if not hardware.set_all_leds_color(color_to_set): 
                    EffectLibrary.logger.warning("Pulse: set_all_leds_color failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                if stop_event.wait(max(MIN_ANIMATION_FRAME_DELAY, delay_factor * 0.1)): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in pulse: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in pulse effect. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Pulse effect stopped.")

    @staticmethod
    @safe_execute()
    def zone_chase(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting zone_chase: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = BASE_ANIMATION_DELAY_SPEED_1 / speed; error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                base_color = color
                if rainbow_mode: state.hue_offset = (state.hue_offset + 0.01 * speed * 0.1) % 1.0
                zone_colors = [RGBColor(0,0,0)] * NUM_ZONES; current_lit_zone = state.position
                if rainbow_mode: block_hue = (state.hue_offset + (current_lit_zone / float(NUM_ZONES))) % 1.0; base_color = RGBColor.from_hsv(block_hue, 1.0, 1.0)
                zone_colors[current_lit_zone] = base_color
                if not hardware.set_zone_colors(zone_colors): 
                    EffectLibrary.logger.warning("ZoneChase: set_zone_colors failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                state.position = (state.position + 1) % NUM_ZONES
                if stop_event.wait(max(MIN_ANIMATION_FRAME_DELAY, delay_factor)): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in zone_chase: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in zone_chase. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Zone chase effect stopped.")

    @staticmethod
    @safe_execute()
    def starlight(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting starlight: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = BASE_ANIMATION_DELAY_SPEED_1 / speed; error_count = 0; max_local_errors = 10
        while not stop_event.is_set():
            try:
                zone_colors = [RGBColor(0,0,0)] * NUM_ZONES
                num_stars = random.randint(1, max(1, NUM_ZONES // 2 + int(speed / 3)))
                for _ in range(num_stars):
                    zone_to_light = random.randint(0, NUM_ZONES - 1)
                    star_brightness = random.uniform(0.3, 1.0); star_color = color
                    if rainbow_mode: star_color = RGBColor.from_hsv(random.random(), 1.0, 1.0)
                    zone_colors[zone_to_light] = star_color.with_brightness(star_brightness)
                if not hardware.set_zone_colors(zone_colors): 
                    EffectLibrary.logger.warning("Starlight: set_zone_colors failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                if stop_event.wait(max(MIN_ANIMATION_FRAME_DELAY, delay_factor * 2)): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in starlight: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in starlight. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Starlight effect stopped.")
    
    @staticmethod
    @safe_execute()
    def raindrop(stop_event: threading.Event, hardware: HardwareController, speed: int, color: Optional[RGBColor]=None, **kwargs):
        EffectLibrary.logger.info(f"Starting raindrop effect: speed={speed}")
        state = EffectState(); palette = [RGBColor.from_hex(h) for h in ["#0077FF", "#00BFFF", "#87CEFA", "#4682B4"]]
        if color and isinstance(color, RGBColor): 
            palette = [color.interpolate(RGBColor(0,0,50), 0.5), color, color.interpolate(RGBColor(200,200,255),0.5)]
        delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / (speed * 1.5)); error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                current_zone_colors = hardware.get_all_zone_colors()
                faded_zone_colors = []
                for zc in current_zone_colors:
                    fade_amount = int(15 + speed)
                    new_r = max(0, zc.r - fade_amount // 3); new_g = max(0, zc.g - fade_amount // 2); new_b = max(0, zc.b - fade_amount)
                    faded_zone_colors.append(RGBColor(new_r, new_g, new_b))
                zone_colors_to_set = faded_zone_colors
                if random.random() < (0.05 + 0.05 * speed):
                    drop_zone = random.randint(0, NUM_ZONES -1) 
                    drop_start_color = random.choice(palette)
                    zone_colors_to_set[drop_zone] = drop_start_color 
                if not hardware.set_zone_colors(zone_colors_to_set): 
                    EffectLibrary.logger.warning("Raindrop: set_zone_colors failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                if stop_event.wait(delay_factor): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in raindrop: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in raindrop. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Raindrop effect stopped.")

    @staticmethod
    @safe_execute()
    def scanner(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting scanner: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(position=0, direction=1); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / (speed * 1.5))
        error_count = 0; max_local_errors = 5; tail_length = max(0, NUM_ZONES // 3 -1) 
        while not stop_event.is_set():
            try:
                base_color_to_use = color
                if rainbow_mode: state.hue_offset = (state.hue_offset + 0.002 * speed)%1.0; base_color_to_use = RGBColor.from_hsv(state.hue_offset, 1.0, 1.0)
                zone_colors = [RGBColor(0,0,0)] * NUM_ZONES
                for i in range(tail_length + 1):
                    pos = state.position - (i * state.direction) 
                    if 0 <= pos < NUM_ZONES:
                        brightness = 1.0 - (i / float(tail_length + 2)) 
                        zone_colors[pos] = base_color_to_use.with_brightness(brightness)
                if not hardware.set_zone_colors(zone_colors): 
                    EffectLibrary.logger.warning("Scanner: set_zone_colors failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                state.position += state.direction
                if state.position >= NUM_ZONES: state.position = NUM_ZONES -1 ; state.direction = -1 
                elif state.position < 0: state.position = 0; state.direction = 1 
                if stop_event.wait(delay_factor): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in scanner: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in scanner. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Scanner effect stopped.")

    @staticmethod
    @safe_execute()
    def strobe(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting strobe: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / (speed * 5)); 
        error_count = 0; max_local_errors = 5; is_on_state = True
        while not stop_event.is_set():
            try:
                base_color_to_use = color
                if rainbow_mode: state.hue_offset = (state.hue_offset + 0.02 * speed)%1.0; base_color_to_use = RGBColor.from_hsv(state.hue_offset, 1.0, 1.0)
                color_to_set = base_color_to_use if is_on_state else RGBColor(0,0,0)
                if not hardware.set_all_leds_color(color_to_set): 
                    EffectLibrary.logger.warning("Strobe: set_all_leds_color failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                is_on_state = not is_on_state
                if stop_event.wait(delay_factor): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in strobe: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in strobe. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Strobe effect stopped.")

    @staticmethod
    @safe_execute()
    def ripple(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, rainbow_mode: bool = False, **kwargs):
        EffectLibrary.logger.info(f"Starting ripple: speed={speed}, color={color.to_hex() if not rainbow_mode else 'RAINBOW'}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / (speed * 2))
        error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                zone_colors = [RGBColor(0,0,0)] * NUM_ZONES
                if random.random() < (0.01 + 0.02 * speed): 
                    center_zone = random.randint(0, NUM_ZONES - 1)
                    ripple_base_hue = random.random() if rainbow_mode else color.to_hsv()[0]
                    state.ripple_sources.append({"center": center_zone, "radius": 0.0, "max_radius": float(NUM_ZONES) * 0.75, "hue": ripple_base_hue, "intensity": 1.0})
                new_ripples = []
                for rip in state.ripple_sources:
                    for zone_idx in range(NUM_ZONES):
                        distance = abs(zone_idx - rip["center"])
                        ripple_width_param = 1.0 
                        if rip["radius"] - ripple_width_param < distance < rip["radius"] + ripple_width_param:
                            dist_from_peak = abs(distance - rip["radius"])
                            brightness_factor = rip["intensity"] * max(0, (1.0 - (dist_from_peak / ripple_width_param)))**2 
                            ripple_color_base = color if not rainbow_mode else RGBColor.from_hsv(rip["hue"], 1.0, 1.0)
                            ripple_eff_color = ripple_color_base.with_brightness(brightness_factor)
                            zone_colors[zone_idx] = RGBColor(
                                r=min(255, zone_colors[zone_idx].r + ripple_eff_color.r),
                                g=min(255, zone_colors[zone_idx].g + ripple_eff_color.g),
                                b=min(255, zone_colors[zone_idx].b + ripple_eff_color.b))
                    rip["radius"] += 0.1 * speed ; rip["intensity"] *= (0.96 - (speed * 0.002)) 
                    if rip["intensity"] > 0.05 and rip["radius"] < rip["max_radius"] + ripple_width_param: new_ripples.append(rip)
                state.ripple_sources = new_ripples
                if not hardware.set_zone_colors(zone_colors): 
                    EffectLibrary.logger.warning("Ripple: set_zone_colors failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                if stop_event.wait(delay_factor): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in ripple: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in ripple. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Ripple effect stopped.")

    @staticmethod
    @safe_execute()
    def rainbow_wave(stop_event: threading.Event, hardware: HardwareController, speed: int, **kwargs):
        EffectLibrary.logger.info(f"Starting rainbow_wave (delegating to wave with rainbow_mode=True): speed={speed}")
        # Call the main 'wave' effect with rainbow_mode explicitly set to True
        # The 'color' param passed here will be ignored by 'wave' if rainbow_mode is True
        EffectLibrary.wave(stop_event, hardware, speed, RGBColor(0,0,0), rainbow_mode=True, **kwargs)
        EffectLibrary.logger.info("Rainbow wave (delegated) effect stopped.")

    @staticmethod
    @safe_execute()
    def rainbow_breathing(stop_event: threading.Event, hardware: HardwareController, speed: int, **kwargs):
        EffectLibrary.logger.info(f"Starting rainbow_breathing (delegating to breathing with rainbow_mode=True): speed={speed}")
        EffectLibrary.breathing(stop_event, hardware, speed, RGBColor(0,0,0), rainbow_mode=True, **kwargs)
        EffectLibrary.logger.info("Rainbow breathing (delegated) effect stopped.")

    @staticmethod
    @safe_execute()
    def rainbow_zones_cycle(stop_event: threading.Event, hardware: HardwareController, speed: int, **kwargs):
        EffectLibrary.logger.info(f"Starting rainbow_zones_cycle: speed={speed}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / speed); error_count = 0; max_local_errors = 5
        while not stop_event.is_set():
            try:
                zone_colors = []
                for zone_idx in range(NUM_ZONES):
                    hue = (state.hue_offset + (zone_idx / float(NUM_ZONES))) % 1.0 
                    zone_colors.append(RGBColor.from_hsv(hue, 1.0, 1.0))
                if not hardware.set_zone_colors(zone_colors): 
                    EffectLibrary.logger.warning("RainbowZonesCycle: set_zone_colors failed."); error_count+=1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                state.hue_offset = (state.hue_offset + 0.002 * speed) % 1.0
                if stop_event.wait(delay_factor): break
                state.frame_count +=1
            except Exception as e: 
                EffectLibrary.logger.error(f"Error in rainbow_zones_cycle: {e}", exc_info=True); error_count+=1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in rainbow_zones_cycle. Stopping."); break
                if stop_event.is_set(): break
        EffectLibrary.logger.info("Rainbow zones cycle effect stopped.")

    @staticmethod
    @safe_execute(max_attempts=1)
    def reactive_pulse(hardware: HardwareController, zone_index_1_based: int, color: RGBColor, duration_ms: int = int(REACTIVE_DELAY * 1000), **kwargs):
        EffectLibrary.logger.debug(f"Reactive pulse on zone {zone_index_1_based} color {color.to_hex()}")
        if not (1 <= zone_index_1_based <= NUM_ZONES): EffectLibrary.logger.warning(f"Invalid zone {zone_index_1_based} for reactive pulse."); return
        
        original_color = hardware.get_zone_color(zone_index_1_based) 
        if original_color is None: original_color = RGBColor(0,0,0) 

        num_steps = 20 ; step_delay = (duration_ms / 1000.0) / num_steps
        if step_delay < MIN_ANIMATION_FRAME_DELAY: step_delay = MIN_ANIMATION_FRAME_DELAY

        try:
            for i in range(num_steps // 2): 
                ratio = i / float(num_steps // 2 -1 if num_steps//2 >1 else 1)
                intermediate_color = original_color.interpolate(color, ratio)
                if not hardware.set_zone_color(zone_index_1_based, intermediate_color): break
                time.sleep(step_delay / 2)
            
            if not hardware.set_zone_color(zone_index_1_based, color): return
            time.sleep(step_delay * 2) 

            for i in range(num_steps // 2): 
                ratio = i / float(num_steps // 2 -1 if num_steps//2 >1 else 1)
                intermediate_color = color.interpolate(original_color, ratio)
                if not hardware.set_zone_color(zone_index_1_based, intermediate_color): break
                time.sleep(step_delay / 2)

            hardware.set_zone_color(zone_index_1_based, original_color)
        except Exception as e: 
            EffectLibrary.logger.error(f"Error in reactive_pulse for zone {zone_index_1_based}: {e}", exc_info=True)
            try: hardware.set_zone_color(zone_index_1_based, original_color) 
            except: pass
    @staticmethod
    @safe_execute()
    def reactive(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, **kwargs):
        """Reactive effect - keys light up only when pressed, all others stay off"""
        EffectLibrary.logger.info(f"Starting reactive effect: speed={speed}, color={color.to_hex()}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / speed)
        error_count = 0; max_local_errors = 5
        
        while not stop_event.is_set():
            try:
                # Reactive mode: all zones off by default, only light up when "pressed"
                # In real implementation, this would respond to actual key presses
                # For demonstration, we simulate random key presses
                zone_colors = [RGBColor(0, 0, 0)] * NUM_ZONES
                
                # Simulate some random "key presses" for demo purposes
                if random.random() < 0.1:  # 10% chance per frame
                    active_zone = random.randint(0, NUM_ZONES - 1)
                    zone_colors[active_zone] = color
                
                if not hardware.set_zone_colors(zone_colors):
                    EffectLibrary.logger.warning("Reactive: set_zone_colors failed."); error_count += 1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                
                if stop_event.wait(delay_factor): break
                state.frame_count += 1
                
            except Exception as e:
                EffectLibrary.logger.error(f"Error in reactive: {e}", exc_info=True); error_count += 1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in reactive. Stopping."); break
                if stop_event.is_set(): break
                
        EffectLibrary.logger.info("Reactive effect stopped.")

    @staticmethod
    @safe_execute()
    def anti_reactive(stop_event: threading.Event, hardware: HardwareController, speed: int, color: RGBColor, **kwargs):
        """Anti-reactive effect - all keys stay on except when pressed, pressed keys turn off"""
        EffectLibrary.logger.info(f"Starting anti-reactive effect: speed={speed}, color={color.to_hex()}")
        state = EffectState(); delay_factor = max(MIN_ANIMATION_FRAME_DELAY, BASE_ANIMATION_DELAY_SPEED_1 / speed)
        error_count = 0; max_local_errors = 5
        
        while not stop_event.is_set():
            try:
                # Anti-reactive mode: all zones on by default, turn off when "pressed"
                zone_colors = [color] * NUM_ZONES
                
                # Simulate some random "key presses" for demo purposes
                if random.random() < 0.1:  # 10% chance per frame
                    active_zone = random.randint(0, NUM_ZONES - 1)
                    zone_colors[active_zone] = RGBColor(0, 0, 0)  # Turn off when "pressed"
                
                if not hardware.set_zone_colors(zone_colors):
                    EffectLibrary.logger.warning("Anti-reactive: set_zone_colors failed."); error_count += 1
                    if error_count >= max_local_errors: break
                    if stop_event.wait(0.5): break
                else: error_count = 0
                
                if stop_event.wait(delay_factor): break
                state.frame_count += 1
                
            except Exception as e:
                EffectLibrary.logger.error(f"Error in anti_reactive: {e}", exc_info=True); error_count += 1
                time.sleep(0.2)
                if error_count >= max_local_errors: EffectLibrary.logger.error("Max errors reached in anti_reactive. Stopping."); break
                if stop_event.is_set(): break
                
        EffectLibrary.logger.info("Anti-reactive effect stopped.")


# Available effects list for EffectManager
AVAILABLE_EFFECTS = [
    "Breathing",
    "Color Cycle", 
    "Wave",
    "Pulse",
    "Zone Chase",
    "Starlight",
    "Raindrop",
    "Scanner", 
    "Strobe",
    "Ripple",
    "Rainbow Wave",
    "Rainbow Breathing", 
    "Rainbow Zones Cycle",
    "Reactive",
    "Anti-Reactive"
]
